taskKey="com.codegym.games.racer.part20"\n\nRacer (Part 20/28)

There are currently too many oncoming cars. To make it possible to win the game, there must be adequate spaces between obstacles.
That said, if they are too big, then the game will become too easy and not very interesting.
The optimal distance is 12, which is slightly larger than the dimensions of the player's car.
We'll store this value in the PLAYER_CAR_DISTANCE constant.

Implement a boolean isRoadSpaceFree(RoadObject object) method that checks whether there is enough room on the road to place a new car.
The isCollisionWithDistance(GameObject, int) method will help you with this. This method returns false if the horizontal and vertical distance between objects is greater than the passed distance.
If the road has enough free space, add a new car to items.


Requirements:
1.	The RoadManager class must have a private static final int PLAYER_CAR_DISTANCE field, initialized to 12 when it is declared.
2.	The RoadManager class must have a private boolean isRoadSpaceFree(RoadObject object) method.
3.	The isRoadSpaceFree(RoadObject object) must call the isCollisionWithDistance(GameObject, int) method on the elements of the items list in order to check for collisions. Pass object and PLAYER_CAR_DISTANCE as arguments.
4.	The isRoadSpaceFree(RoadObject) method must return false if the isCollisionWithDistance(GameObject, int) method returns true for any objects in the items list.
5.	The isRoadSpaceFree(RoadObject) method must return true if the isCollisionWithDistance(GameObject, int) method returns false for every object in the items list.
6.	The addRoadObject(RoadObjectType, Game) method must call the isRoadSpaceFree(RoadObject) method.
7.	The addRoadObject(RoadObjectType, Game) method must add the object created by the createRoadObject(RoadObjectType, int, int) method to the items list only if the isRoadSpaceFree(RoadObject) method returns true.


Racer (Part 19/28)

In addition to spikes, it would be nice to see various types of cars on the race track.
To represent cars on the playing field, in the road package, create a Car class that will be common to all types of cars and make it inherit RoadObject.
All cars will move at a speed of 1.

Because the RoadManager class's createRoadObject(RoadObjectType, int, int) method is responsible for creating all road objects, it must return a new Car object instead of null.
To generate new cars, create a generateRegularCar(Game game) method in the RoadManager class.
To avoid excessively crowding the race track, a new car should be created with a 30% probability.
The type of car must be randomly selected from the first four fields of the RoadObjectType enum.
Don't forget to add each generated car to the items list.



Racer (Part 18/28)

After the game is over, the player must be able to start a new game. Implement the ability to restart the game by pressing the SPACE key.

To allow the player to cover the race track faster, his or her car must be able to accelerate.
Implement the ability to double the speed by pressing the UP key. Releasing this key must return the car to the initial speed.



Racer (Part 17/28)

The game must stop in two cases: when the player wins or when the player loses. For now, we'll only stop the game for losses.
To save the current game state, we'll create a boolean isGameStopped field whose initial value must be false.

When the player hits an obstacle, he or she loses. This means that the player must be stopped, and a message, such as GAME OVER,
must be displayed on the screen.
It is convenient to put all the actions associated with a lose in a separate gameOver() method.
The onTurn(int) method must check whether the player has collided with any obstacles (checkCrash(PlayerCar) method).



Racer (Part 16/28)

Currently, the player's car continues to move after colliding with an obstacle. In this part of the project,
we'll implement a method that will check whether the car has hit an obstacle.
When implementing this method, use the GameObject class's isCollision(GameObject) method, which we have implemented for you.
Figure out how it works.

Collisions should be visibly noticeable, i.e. we need to change the image used to display the player's car.
To do this, give the PlayerCar class a stop() method that sets the matrix field to ShapeMatrix.PLAYER_DEAD.



Racer (Part 15/28)

Currently, spikes appear only once (at the beginning of the game). To generate a new spike, the old spike must be removed
from the items list after its leaves the screen. To remove the spike, you can either use an iterator, or
create a copy of the items list and run through it in a loop. If an object needs to be removed, call items.remove(item).



