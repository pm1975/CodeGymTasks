taskKey="com.codegym.games.racer.part22"\n\nRacer (Part 22/28)

Let's move on to creating the finish line. A matrix for it is already in ShapeMatrix.
The finish line appears on the race track at the end of the game.
Actually, the object representing the finish line is created at the beginning of the game, but it is located beyond
the playing field, so it is not visible.
As soon as the flag responsible for the FinishLine object's visibility becomes true, the finish line starts to move down
and appears on the playing field.


Requirements:
1.	There must be a public FinishLine class in a separate file.
2.	The FinishLine class must be a descendant of the GameObject class.
3.	The FinishLine class must have a public no-parameter constructor that calls the base class&#39;s constructor with the following arguments: RacerGame.ROADSIDE_WIDTH, -1 * ShapeMatrix.FINISH_LINE.length, ShapeMatrix.FINISH_LINE.
4.	The FinishLine class must have a private boolean isVisible field, initialized to false when it is declared.
5.	The FinishLine class must have a public void show() method.
6.	The show() method must set the isVisible field to true.
7.	The FinishLine class must have a public void move(int boost) method.
8.	The move(int) method must not do anything if the finish line is not visible (isVisible equals false).
9.	The move(int boost) method must increase the finish line&#39;s y coordinate by the value of boost.


Racer (Part 21/28)

Let's make the game a little harder. Let's add a car whose driver is "drunk".
To represent it on the playing field, the MovingCar class has been added to the road package. Use it to create these cars.
Unlike ordinary cars, a car operated by a "drunk" driver will drift horizontally.
To prevent it from hitting other cars, the MovingCar class's move() method checks for such collisions.
To do this, in addition to the speed, you need to pass the list of all obstacle objects to the move(int boost) method.

There is another nuance: MovingCar inherits RoadObject and overrides its move method, so you'll also have to add a second parameter to the move method in the parent class.

When there are a lot of "drunk" drivers on the race track, the game becomes too difficult, so ensure that there is only one such car on the race track at a time.
To check this, implement the movingCarExists() method by analogy with the spikeExists() method.

The void generateMovingCar(Game) method will be responsible for generating MovingCar objects.
Its implementation is analogous to the generateSpike(Game) method.



Racer (Part 20/28)

There are currently too many oncoming cars. To make it possible to win the game, there must be adequate spaces between obstacles.
That said, if they are too big, then the game will become too easy and not very interesting.
The optimal distance is 12, which is slightly larger than the dimensions of the player's car.
We'll store this value in the PLAYER_CAR_DISTANCE constant.

Implement a boolean isRoadSpaceFree(RoadObject object) method that checks whether there is enough room on the road to place a new car.
The isCollisionWithDistance(GameObject, int) method will help you with this. This method returns false if the horizontal and vertical distance between objects is greater than the passed distance.
If the road has enough free space, add a new car to items.



Racer (Part 19/28)

In addition to spikes, it would be nice to see various types of cars on the race track.
To represent cars on the playing field, in the road package, create a Car class that will be common to all types of cars and make it inherit RoadObject.
All cars will move at a speed of 1.

Because the RoadManager class's createRoadObject(RoadObjectType, int, int) method is responsible for creating all road objects, it must return a new Car object instead of null.
To generate new cars, create a generateRegularCar(Game game) method in the RoadManager class.
To avoid excessively crowding the race track, a new car should be created with a 30% probability.
The type of car must be randomly selected from the first four fields of the RoadObjectType enum.
Don't forget to add each generated car to the items list.



Racer (Part 18/28)

After the game is over, the player must be able to start a new game. Implement the ability to restart the game by pressing the SPACE key.

To allow the player to cover the race track faster, his or her car must be able to accelerate.
Implement the ability to double the speed by pressing the UP key. Releasing this key must return the car to the initial speed.



Racer (Part 17/28)

The game must stop in two cases: when the player wins or when the player loses. For now, we'll only stop the game for losses.
To save the current game state, we'll create a boolean isGameStopped field whose initial value must be false.

When the player hits an obstacle, he or she loses. This means that the player must be stopped, and a message, such as GAME OVER,
must be displayed on the screen.
It is convenient to put all the actions associated with a lose in a separate gameOver() method.
The onTurn(int) method must check whether the player has collided with any obstacles (checkCrash(PlayerCar) method).



