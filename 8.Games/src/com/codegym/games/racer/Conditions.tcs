taskKey="com.codegym.games.racer.part26"\n\nRacer (Part 26/28)

The player win's when he or she crosses the finish line.

To check whether the player has crossed the finish line, you need to compare his or her y coordinate with the y of the finish line. If the player's y coordinate is less than the finish line's y coordinate, then the line has been crossed.
In the FinishLine class, create a separate isCrossed(PlayerCar) method to compare the y coordinates.
You need to call the isCrossed(PlayerCar) method at each step of the game. When the finish line is crossed, the game must be stopped and the player must be informed of the win.
Implement this in the win() method.


Requirements:
1.	The FinishLine class must have a public boolean isCrossed(PlayerCar) method.
2.	The isCrossed(PlayerCar player) method must return true if the player has crossed the finish line. Otherwise, it should return false.
3.	The RacerGame class must have a private void win() method.
4.	In the win() method, you must set the isGameStopped field to true.
5.	The win() method must call the showMessageDialog(Color, String, Color, int) method.
6.	The stopTurnTimer() method must be called in the win() method.
7.	In the RacerGame class&#39;s onTurn(int) method, you need to call the isCrossed(PlayerCar) method on the finishLine object before moveAll().
8.	In the RacerGame class&#39;s onTurn(int) method, you need to call the win() method if the isCrossed(PlayerCar) method returns true.
9.	In the RacerGame class&#39;s onTurn(int) method, if the isCrossed(PlayerCar) method returns true, you need to call the drawScene() method after the win() method and do nothing more.


Racer (Part 25/28)

In this part of the project, we'll add a progress bar to indicate the player's progress through the game.

Note that you have a new class: ProgressBar. Figure out how it works and what it does?
To store an instance of the ProgressBar class, we'll need a corresponding field in the game's main class. This field will be initialized at the start of a new game.
The size of the progress bar will depend on the number of cars that the player must pass. This value is passed to the constructor.

Our progress bar will be redrawn with each tick of the game, and the displayed progress will change with the number of passed car obstacles.



Racer (Part 24/28)

To check the win condition, we'll need to know the actual number of cars that the player has passed.
To do this, create a passedCarsCount field and corresponding getter in the RoadManager class.
The value of this field must increase by one after the player passes each car obstacle (removal of a car from the items list).

We'll compare passedCarsCount and RACE_GOAL_CARS_COUNT in the onTurn(int) method.
If the value of passedCarsCount is greater or equal to RACE_GOAL_CARS_COUNT, then the player has reached the goal and we need to show the finish line.



Racer (Part 23/28)

In this part of the project, we'll draw and move the finish line. To do this, an instance must be stored in the game's main class and recreated when a new game starts.
Like the methods of our other objects, the FinishLine class's draw(Game) and move(int) methods will be called every 40 ms, but the results of these method calls will be ignored until the show() method is called.
Let's also determine the conditions necessary for a win. To make the game challenging and interesting, a win should happen after the player clears 40 car obstacles.
We'll store this value in the RACE_GOAL_CARS_COUNT constant.



Racer (Part 22/28)

Let's move on to creating the finish line. A matrix for it is already in ShapeMatrix.
The finish line appears on the race track at the end of the game.
Actually, the object representing the finish line is created at the beginning of the game, but it is located beyond
the playing field, so it is not visible.
As soon as the flag responsible for the FinishLine object's visibility becomes true, the finish line starts to move down
and appears on the playing field.



Racer (Part 21/28)

Let's make the game a little harder. Let's add a car whose driver is "drunk".
To represent it on the playing field, the MovingCar class has been added to the road package. Use it to create these cars.
Unlike ordinary cars, a car operated by a "drunk" driver will drift horizontally.
To prevent it from hitting other cars, the MovingCar class's move() method checks for such collisions.
To do this, in addition to the speed, you need to pass the list of all obstacle objects to the move(int boost) method.

There is another nuance: MovingCar inherits RoadObject and overrides its move method, so you'll also have to add a second parameter to the move method in the parent class.

When there are a lot of "drunk" drivers on the race track, the game becomes too difficult, so ensure that there is only one such car on the race track at a time.
To check this, implement the movingCarExists() method by analogy with the spikeExists() method.

The void generateMovingCar(Game) method will be responsible for generating MovingCar objects.
Its implementation is analogous to the generateSpike(Game) method.



