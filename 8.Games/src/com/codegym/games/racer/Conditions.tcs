taskKey="com.codegym.games.racer.part11"\n\nRacer (Part 11/28)

The player will face various obstacles on the road: other cars driving the wrong way, and spikes that don't move relative
to the race track. These obstacles will inherit the RoadObject class. The types of all possible obstacles are listed in the
RoadObjectType enum. You now have access to these classes in the road package. And new matrices for displaying obstacles
have been added to the ShapeMatrix class. Take a look at the RoadObject class and its methods.

At this stage, we'll implement the spikes. Create a Spike class and make it inherit RoadObject. To create instances of obstacles,
in the RoadManager class, create a private RoadObject createRoadObject(RoadObjectType type, int x, int y) method that will
create and return a new obstacle based on the passed arguments.
We currently only have one type of obstacle: Spike, so if the createRoadObject method receives any other type as an argument,
it should return null. Since we know the game object's type, there is no need to pass an image matrix to its constructor.
Accordingly, the GameObject class will need one more constructor with two int parameters (int x, int y), which are used to
initialize the x and y fields.


Requirements:
1.	The GameObject class must have a public constructor with two parameters (int x, int y). It must use the parameters to set the x and y fields.
2.	There must be a public Spike class in a separate file in the road package.
3.	The Spike class must inherit the RoadObject class.
4.	The Spike class must have a public constructor with two parameters (int x, int y). It must call the base class constructor with the following arguments: RoadObjectType.SPIKE, x, y.
5.	In the Spike class&#39;s constructor, the speed field (inherited from the parent class) must be initialized to 0.
6.	The RoadManager class must have a private RoadObject createRoadObject(RoadObjectType type, int x, int y) method.
7.	The createRoadObject(RoadObjectType, int, int) method must return a new Spike object if type is equal to RoadObjectType.SPIKE.
8.	The createRoadObject(RoadObjectType, int, int) method must return null if type is not equal to RoadObjectType.SPIKE.
9.	The createRoadObject(RoadObjectType, int, int) method must call the Spike class&#39;s constructor with the method&#39;s x and y parameters.


Racer (Part 10/28)

The car's behavior currently doesn't match what we would expect:
- the car doesn't stop moving to the side when an arrow key is released;
- the car drives right off the edge of the road and the playing field.
To fix this, you need to implement the correct behavior for the car when the RIGHT and LEFT keys are released.
Override the onKeyReleased(Key) method and there set the car's direction to Direction.NONE when this is necessary.
Create a RoadManager class in the road package in order to manage the flow of items on the road. Give it fields that will store the x coordinates of the edges of the driving surface.
Use them in the PlayerCar class's move() method to prevent the car from leaving the road.
If you check the road boundary before changing the x coordinate of the player's car, it will be able to put one wheel on the shoulder. But if you change x first and then check the boundary, the player's car will be strictly limited to the race track.
The choice is yours.



Racer (Part 9/28)

Along the horizontal axis, the car can move right, left, or not at all. To indicate these directions, create a Direction
enum with the following fields. RIGHT, LEFT, NONE.
The player's car must have a field that stores the direction of motion (Direction direction).
We'll access it through a getter and setter.
In the PlayerCar class, create a move() method that changes the car's coordinates along the horizontal axis depending on its
direction of motion. This method will be called in moveAll().
To handle key presses, override the onKeyPress(Key) method. Depending on which key is pressed, use a setter to set
the appropriate direction of the player's car.



Racer (Part 8/28)

The dashed lines must move to create the illusion that the car is moving. The car itself will always be located below the game field.
We'll give the car a field responsible for speed. Its value will be passed to roadMarking.move(int) and indicates how much the markings need to move.
In RacerGame, we'll create a moveAll() method that will move all movable game objects (for now, only the marking). moveAll() must be called every 40 ms. To do this, in RacerGame you need to override the onTurn(int) and set the interval in the createGame() method.

You can read about how to work with the onTurn(int) method in the description of the game engine:
https://codegym.cc/groups/posts/139-games-section-on-codegym-event-handling



Racer (Part 7/28)

Now we'll create the player's car.
Let's create a PlayerCar class and make it inherit GameObject:
At first, the player's car will be in the third lane, one position above the bottom edge of the playing field.
Accordingly, the x coordinate will be equal to RacerGame.WIDTH/2 + 2, and the y coordinate will be RacerGame.HEIGHT - playerCarHeight - 1.
A matrix for the car is already in ShapeMatrix. In order to reference the player's car, an instance of PlayerCar must be stored in the player variable in the RacerGame class. Call the draw(Game) method on the car to see it on the playing field.



Racer (Part 6/28)

The road, shoulders, and dividing line are stationary objects: they do not move.
Motion will be simulated by other game objects. We don't have cars yet. For now, only two dashed lines on the road will move.
Other road markings will be represented by a separate class. You don't need to create it. You have the RoadMarking class in
your game package. Take a look at the code of this class. In addition to a constructor, RoadMarking has 2 other methods: move(int) - responsible for movement annd draw(Game) - responsible for drawing the object. At this stage, we'll only implement the drawing. The draw(Game) method takes the object that should be drawn on. In our case, it is the current instance of the RacerGame class, i.e. this.
You also now have a ShapeMatrix class that stores int matrices containing images of game objects.
The numbers in the matrix represent the ordinals of colors in the Color enum. Thanks to the image matrices, the object knows what
color to paint each cell. ShapeMatrix currently only has a matrix for the road's dashed line, but in the future other objects' images
will be added as well.
Give the RacerGame class a RoadMarking field, initialize it in the createGame() method, and draw it in the drawScene() method.
The dashed line must be drawn after (on top of) the stationary objects.



