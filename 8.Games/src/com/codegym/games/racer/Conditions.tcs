taskKey="com.codegym.games.racer.part09"\n\nRacer (Part 9/28)

Along the horizontal axis, the car can move right, left, or not at all. To indicate these directions, create a Direction
enum with the following fields. RIGHT, LEFT, NONE.
The player's car must have a field that stores the direction of motion (Direction direction).
We'll access it through a getter and setter.
In the PlayerCar class, create a move() method that changes the car's coordinates along the horizontal axis depending on its
direction of motion. This method will be called in moveAll().
To handle key presses, override the onKeyPress(Key) method. Depending on which key is pressed, use a setter to set
the appropriate direction of the player's car.


Requirements:
1.	 There must be a public Direction enum with the following values in a separate file: NONE, RIGHT, LEFT.
2.	The PlayerCar class must have a private Direction direction field.
3.	The PlayerCar class must have a public setDirection(Direction) setter that sets the value of the direction field.
4.	The PlayerCar class must have a public getDirection() getter that returns the value of the direction field.
5.	The PlayerCar class must have a public void move() method.
6.	In the PlayerCar class&#39;s move() method, if the direction field is equal to Direction.LEFT, the x coordinate must be reduced by one.
7.	In the PlayerCar class&#39;s move() method, if the direction field is equal to Direction.RIGHT, the x coordinate must be increased by one.
8.	In the RacerGame class&#39;s moveAll() method, the move() method must be called on the player object.
9.	In the RacerGame class, the onKeyPress(Key) method of the Game parent class must be overridden.
10.	The onKeyPress(Key) method must set the player&#39;s direction to Direction.RIGHT if the method&#39;s parameter is equal to Key.RIGHT.
11.	The onKeyPress(Key) method must set the player&#39;s direction to Direction.LEFT if the method&#39;s parameter is equal to Key.LEFT.


Racer (Part 8/28)

The dashed lines must move to create the illusion that the car is moving. The car itself will always be located below the game field.
We'll give the car a field responsible for speed. Its value will be passed to roadMarking.move(int) and indicates how much the markings need to move.
In RacerGame, we'll create a moveAll() method that will move all movable game objects (for now, only the marking). moveAll() must be called every 40 ms. To do this, in RacerGame you need to override the onTurn(int) and set the interval in the createGame() method.

You can read about how to work with the onTurn(int) method in the description of the game engine:
https://codegym.cc/groups/posts/139-games-section-on-codegym-event-handling



Racer (Part 7/28)

Now we'll create the player's car.
Let's create a PlayerCar class and make it inherit GameObject:
At first, the player's car will be in the third lane, one position above the bottom edge of the playing field.
Accordingly, the x coordinate will be equal to RacerGame.WIDTH/2 + 2, and the y coordinate will be RacerGame.HEIGHT - playerCarHeight - 1.
A matrix for the car is already in ShapeMatrix. In order to reference the player's car, an instance of PlayerCar must be stored in the player variable in the RacerGame class. Call the draw(Game) method on the car to see it on the playing field.



Racer (Part 6/28)

The road, shoulders, and dividing line are stationary objects: they do not move.
Motion will be simulated by other game objects. We don't have cars yet. For now, only two dashed lines on the road will move.
Other road markings will be represented by a separate class. You don't need to create it. You have the RoadMarking class in
your game package. Take a look at the code of this class. In addition to a constructor, RoadMarking has 2 other methods: move(int) - responsible for movement annd draw(Game) - responsible for drawing the object. At this stage, we'll only implement the drawing. The draw(Game) method takes the object that should be drawn on. In our case, it is the current instance of the RacerGame class, i.e. this.
You also now have a ShapeMatrix class that stores int matrices containing images of game objects.
The numbers in the matrix represent the ordinals of colors in the Color enum. Thanks to the image matrices, the object knows what
color to paint each cell. ShapeMatrix currently only has a matrix for the road's dashed line, but in the future other objects' images
will be added as well.
Give the RacerGame class a RoadMarking field, initialize it in the createGame() method, and draw it in the drawScene() method.
The dashed line must be drawn after (on top of) the stationary objects.



Racer (Part 5/28)

Create a GameObject class to represent game objects. All game objects will have the following common properties:
- int x, int y — coordinates of the object's upper left corner on the playing field;
- int[][] matrix — matrix for displaying the game object. The matrix values are the ordinals of the colors in the Color enum.
To get the color, use Color.values()[matrix[i][j]], where:
i is the y coordinate in the matrix,
j is the x coordinate in the matrix.
- int height, int width — The height and width match the dimensions of the matrix.
An object must also have a method that draws it.



Racer (Part 4/28)

During the game, many objects will appear, move about the playing field, and sometimes leave it.
If the setCellColor(int, int, Color) method is called with coordinates outside the bounds of the playing field, an exception
will be thrown. To avoid this, override it so that the superclass's method is only called with coordinates that lie within the playing field.
Hint: to call the superclass's method, use the super keyword.



