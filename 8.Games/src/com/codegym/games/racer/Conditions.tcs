taskKey="com.codegym.games.racer.part17"\n\nRacer (Part 17/28)

The game must stop in two cases: when the player wins or when the player loses. For now, we'll only stop the game for losses.
To save the current game state, we'll create a boolean isGameStopped field whose initial value must be false.

When the player hits an obstacle, he or she loses. This means that the player must be stopped, and a message, such as GAME OVER,
must be displayed on the screen.
It is convenient to put all the actions associated with a lose in a separate gameOver() method.
The onTurn(int) method must check whether the player has collided with any obstacles (checkCrash(PlayerCar) method).


Requirements:
1.	The RacerGame class must have a private boolean isGameStopped field.
2.	The isGameStopped field must be initialized to false in the createGame() method.
3.	The RacerGame class must have a private void gameOver() method.
4.	In the gameOver() method, you must set the isGameStopped field to true.
5.	The gameOver() method must call the showMessageDialog(Color, String, Color, int) method.
6.	The stopTurnTimer() method must be called in the gameOver() method.
7.	In the gameOver() method, the stop() method must be called on the player object.
8.	In the RacerGame class&#39;s onTurn(int) method, you need to call the checkCrash(PlayerCar) method on the roadManager object before the call to the moveAll() method.
9.	In the RacerGame class&#39;s onTurn(int) method, you need to call the gameOver() method if the checkCrash(PlayerCar) method returns true.
10.	In the RacerGame class&#39;s onTurn(int) method, if checkCrash(PlayerCar) returns true, you need to call the drawScene() method after the gameOver() method and do nothing more.


Racer (Part 16/28)

Currently, the player's car continues to move after colliding with an obstacle. In this part of the project,
we'll implement a method that will check whether the car has hit an obstacle.
When implementing this method, use the GameObject class's isCollision(GameObject) method, which we have implemented for you.
Figure out how it works.

Collisions should be visibly noticeable, i.e. we need to change the image used to display the player's car.
To do this, give the PlayerCar class a stop() method that sets the matrix field to ShapeMatrix.PLAYER_DEAD.



Racer (Part 15/28)

Currently, spikes appear only once (at the beginning of the game). To generate a new spike, the old spike must be removed
from the items list after its leaves the screen. To remove the spike, you can either use an iterator, or
create a copy of the items list and run through it in a loop. If an object needs to be removed, call items.remove(item).



Racer (Part 14/28)

The time has come to draw the spike on the screen.

There must not be more than one Spike object on the screen at the same time.
To check this condition, create a spikeExists() method in the RoadManager class.
To check whether the RoadObject is a spike, you can use its type field.

The void generateSpike(Game) method will be responsible for generating spikes.
It will check whether there is a spike on the road. If not, then a new spike is generated with a 10% probability.
In the future, things other than spikes may be obstacles. We'll need the generateNewRoadObjects(Game) method to generate all different kinds of obstacles, but for now it will only generate spikes. It must be called in the RacerGame class's onTurn(int) method.

Additionally, the spike must move together with the race track in the moveAll() method.



Racer (Part 13/28)

The RoadManager class's name isn't arbitrary: it manages all the obstacles on the road.
It must know how to draw and move all the stored objects.

In the RacerGame class, create a RoadManager roadManager field so you can access it.
Initialize the roadManager field in createGame(), and call draw(Game) on it in drawScene().



Racer (Part 12/28)

Obstacles must appear at random locations on the road.

Add two constants to the RoadManager class: FIRST_LANE_POSITION and FOURTH_LANE_POSITION — the far left and far right road positions
of the x coordinates of the obstacles' matrices. Assign them the values 16 and 44 respectively.

Additionally, the RoadManager class must have a list of all current obstacle objects.

In the same class, create a addRoadObject(RoadObjectType, Game) method that generates a position for a new obstacle and adds it
to the list of all obstacle objects. The obstacle's coordinates must be generated as follows:

x = game.getRandomNumber(FIRST_LANE_POSITION, FOURTH_LANE_POSITION) — a random lane number;
y = -1 * RoadObject.getHeight(type) — initially, the object is placed beyond the playing field so that it makes a smooth appearance.



