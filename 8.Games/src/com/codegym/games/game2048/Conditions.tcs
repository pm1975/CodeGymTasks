taskKey="com.codegym.games.game2048.part13"\n\n2048 (Part 13/18)

The basic game logic is in place, but it's not entirely complete. Based on the rules and the name of the game, the game ends
when the value of one of the tiles becomes 2048.

You need to search for the maximum value on the game board in a separate int getMaxTileValue() method that returns
the maximum value. You can perform the check for the winning condition anywhere. For example, at the beginning
of the createNewNumber() method, or before adding a new value to the matrix.

When a tile whose value is 2048 is found, you need to inform the player that he or she has won. To make it beautiful, call
the Game class's showMessageDialog(Color cellColor, String message, Color textColor, int textSize) method.
I don't think I need to explain what to pass to this method: the parameter names speak for themselves.

After a win, the current game ends. In the future, we'll need a certain isGameStopped flag.
If the game is won, the flag will be equal to true.
Let's put everything described above (displaying a message about winning, the flag about the game being stopped) in a separate method, which we'll call win().


Requirements:
1.	The private int getMaxTileValue() method must be created in the Game2048 class. The method must return the maximum value in the gameField matrix.
2.	A private boolean isGameStopped variable must be created in the Game2048 class and initialized to false when it is declared.
3.	The private void win() method must be created in the Game2048 class.
4.	The isGameStopped variable must be set to true in the win() method.
5.	The showMessageDialog(Color, String, Color, int) method must be called in the win() method.
6.	The createNewNumber() method must call the getMaxTileValue() method.
7.	The win() method must be called in the createNewNumber() method if the value 2048 is in the matrix.


2048 (Part 12/18)

Now you can start implementing the moveRight(), moveUp(), and moveDown() methods.

In the moveRight() method, rotate the gameField matrix clockwise twice, then call moveLeft(),
which we've already written, and again rotate the gameField clockwise two more times. It should work.

In the moveDown() method, rotate 90 degrees once, then call moveLeft() and rotate 90 degrees another 3
times.

In the moveUp() method, we first rotate 90 degrees three times, and then call moveLeft() and rotate 90
degrees
one more time.



2048 (Part 11/18)

The moveLeft() method is implemented, but there are still 3 other methods. Let's implement them as follows:
if we need to move tiles
down, we take our gameField matrix, rotate it 90 degrees clockwise (so the bottom becomes the left edge),
shift to the left, and rotate the matrix back (rotate clockwise by 90 degrees 3 more
times). The remaining methods are similar.

Let's start with the rotation of the gameField matrix. Here's how it should look:
(2, 2, 2, 2),    (0, 8, 4, 2),
(4, 4, 4, 4),  (0, 8, 4, 2),
(8, 8, 8, 8),    (0, 8, 4, 2),
(0, 0, 0, 0),    (0, 8, 4, 2)



2048 (Part 10/18)

We already know which methods are invoked by which keystrokes. So let's start implementing
them. Let's start with the moveLeft method().

In the moveLeft() method, we shift the elements of each row of the gameField matrix
using the compressRow(int[]) method. We merge their values using the mergeRow(int[]) method, and then we
shift again (since empty spaces may appear after
the merging).
Each row of the gameField matrix must be passed to these methods in turn.
For example:
Initial row: {2, 2, 0, 2}
After compressRow(int[]): {2, 2, 2, 0}
After mergeRow(int[]): {4, 0, 2, 0}
After compressRow(int[]): {4, 2, 0, 0}

If at least one shift or merger takes place, we consider a move to have been made,
and we add a new number to the array by calling the createNewNumber() method.

To made this visible on the screen, you need to call our drawScene() method at the end.



2048 (Part 9/18)

You can play the game using the keyboard, specifically the up arrow, down arrow, right arrow, and left arrow
keys. When a key is pressed, the corresponding action should happen (shift, merge). To specify the action, you need to
override the Game class's onKeyPress(Key key) method, where the parameter is the pressed key.
In this method, you need to compare the key parameter with the four directions in the Key enum and execute
the appropriate action.

For example:
if (key == Key.LEFT) {
// Move left
} else if (key == Key.RIGHT) {
// Move right
} etc.

We suggest putting the actions themselves in appropriate methods.
In other words, movement to the left should be put in a moveLeft() method, etc. In the end, there should be
4 methods for the 4 actions.



2048 (Part 8/18)

You already know how to move tiles across the board. But that's not all you can do in this game :)
If a shift causes two tiles with the same value to "collide", then they merge into one tile
whose value is equal to the sum of the merged tiles. Let's implement it.

Task conditions:
Create a private boolean mergeRow(int[] row) method that merges adjacent pairs of identical non-zero
elements
of the row array. Merging should happen when you shift to the left.

If there are more than two consecutive identical non-zero elements, merge the leftmost first.
Merged elements are not merged again in the same move.

The method must return true if at least one array element was changed, otherwise — false.

Here are some examples:
- Before (4, 4, 0, 0), after (8, 0, 0, 0). The method returns true.
- Before (2, 2, 2, 2), after (4, 0, 4, 0). The method returns true.
- Before (4, 2, 2, 0), after (4, 4, 0, 0). The method returns true.
- Before (0, 2, 2, 0), after (0, 4, 0, 0). The method returns true.
- Before (0, 2, 2, 2), after (0, 4, 0, 2). The method returns true.
- Before (4, 0, 4, 0), after (4, 0, 4, 0). The method returns false.



