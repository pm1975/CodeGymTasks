taskKey="com.codegym.games.spaceinvaders.part09"\n\nSpace Invaders (Part 9/34)

Everything will move in the game, which means that we need to specify the direction in which objects are moving. It is convenient to store directions in an enum.
We'll describe the motion of an enemy ship in the move() method. The method will change the appropriate coordinate depending on direction and speed.
The downward speed will be a constant 2. Because the enemy fleet moves back and forth between edges of the playing field, we need to watch for when the fleet reaches the edges.


Requirements:
1.	There must be a public Direction enum with the following values in a separate file: RIGHT, LEFT, UP, DOWN.
2.	The EnemyShip class must have a public void move(Direction direction, double speed) method.
3.	In the move(Direction direction, double speed) method, you need to increase the x field by speed if direction is equal to Direction.RIGHT.
4.	In the move(Direction direction, double speed) method, you need to decrease the x field by speed if direction is equal to Direction.LEFT.
5.	In the move(Direction direction, double speed) method, you need to increase the y field by 2 if direction is equal to Direction.DOWN.
6.	The EnemyFleet class must have a private double getLeftBorder() method.
7.	The getLeftBorder() method must return the smallest x coordinate of all of the enemy ships in the ships list.
8.	The EnemyFleet class must have a private double getRightBorder() method.
9.	The getRightBorder() method must return the largest (x + width) value of all of the enemy ships in the ships list.


Space Invaders (Part 8/34)

Let's continue working on the enemy fleet. To do this, we need to fill the ships list in the createShips() method.
Keep in mind that the best distance from the top of the screen to the top row of ships is 12 cells.
To add the enemy fleet to the game, we'll create an enemyFleet field in the SpaceInvadersGame class and initialize it to a new EnemyFleet object.
The enemy ships are created when the createShips method is called in the EnemyFleet constructor.
The game is dynamic, so we'll need to regularly redraw the screen and perform other actions. Everything that happens at each step is performed in the onTurn(int) method.
We'll use the setTurnTimer method to set how often this method is called. It takes an argument that determines how long each step is in milliseconds.
In other words, given a step of 40 ms (0.04 second), the onTurn method will be called 25 times per second (1 / 0.04 second).
If you've done everything correctly, you'll see the enemy fleet when you run the program.



Space Invaders (Part 7/34)

In this part of the project, we'll prepare the foundation for the enemy fleet. To do this, we'll create an EnemyFleet class.
It will store the list of ships, number of rows of ships (ROWS_COUNT), number of ships per row (COLUMNS_COUNT),
and distance between left corners of adjacent ships (STEP). We'll create the ships and add them to the ships list in the createShips method,
which we will implement later.



Space Invaders (Part 6/34)

Now we'll create a Ship class that will store properties that all spaceships share. It will have a setStaticView method that at present will set a matrix.
Later, it will set an animation. First, we make a class for ships in the enemy's fleet: EnemyShip. We've provided its matrix for you in the ShapeMatrix class.



Space Invaders (Part 5/34)

Stars aren't the only objects in this game. We will also need spaceships, of course! A game object's appearance is determined by a matrix,
so we'll add a matrix field to the GameObject class. In addition to the object's outline, the matrix contains the ordinals of colors
in the com.codegym.engine.cell.Color enum. We'll put the object's dimensions into separate width and height fields. To draw a game object on the screen,
we'll create a draw(Game game) method. For each cell in the matrix, we'll have this method call the setCellValueEx(int x, int y, Color color, String text)
method on the Game object passed to it as an argument. To draw the matrix on the playing field, we need to consider the x and y coordinates of the GameObject object.
These coordinates are the coordinates of the upper left cell of the matrix on the playing field.

For example:


As you can see from the example, the upper left corner of the game object's matrix has coordinates x = 2 and y = 4 on the playing field.
However, relative to its own matrix, these coordinates are x = 0 and y = 0. Accordingly, the setCellValueEx method will be passed the coordinates
of the upper left corner of the game object's matrix on the playing field + the coordinates of the cell within the game object's matrix (x = 2 + 0, y = 4 + 0).

For example:
game.setCellValueEx(x of the object on the playing field + x in the matrix, y of the object on the playing field + y in the matrix, color, empty string);
Note that color is the color of the cell in the object's matrix. You can get it like this: Color.values()[matrix[i][j]],
where i is the y coordinate in matrix and j is the x coordinate in matrix.



Space Invaders (Part 4/34)

We can use any Unicode symbol to represent stars. We'll store it in the Star class's STAR_SIGN field.
To draw stars on the playing field, we'll create a draw(Game) method. We'll have it call the setCellValueEx method on the Game object passed to it as an argument.
We'll pass the star's coordinates, background color, symbol, color, and size to the setCellValueEx method. Note that the star's x and y coordinates are doubles,
so you need to convert them to int when calling the setCellValueEx method. To add stars to the game, we'll create a list of stars and a method that will fill
the list with new stars. And to draw the stars on the playing field, you need to call the draw(Game) method on each star after drawing the playing field.



