taskKey="com.codegym.games.spaceinvaders.part16"\n\nSpace Invaders (Part 16/34)

Now we'll create the player's ship. We need the PlayerShip class for this. Its constructor will set the ship's coordinates so that
the ship is displayed centered at the bottom of the screen. The constructor sets the ship's appearance by setting the PLAYER matrix,
which we've provided for you in the ShapeMatrix class. A ship can have two states: "alive" or "dead". To represent these states,
we'll add an isAlive field to the Ship parent class. When a projectile hits a ship, they (the projectile and the ship) are destroyed,
so we'll add a kill method. When it is called, we'll "kill" the ship and the projectile.


Requirements:
1.	There must be a public PlayerShip class in a separate file in the gameobjects package.
2.	The PlayerShip class must be a descendant of the Ship class.
3.	The PlayerShip class must have a public no-parameter constructor that calls the base class&#39;s constructor with the following arguments: SpaceInvadersGame.WIDTH / 2.0, SpaceInvadersGame.HEIGHT - ShapeMatrix.PLAYER.length - 1
4.	The PlayerShip class&#39;s constructor must call the setStaticView(int[][]) method. Pass ShapeMatrix.PLAYER as the argument.
5.	The Ship class must have a public boolean isAlive field that is initialized to true when it is declared.
6.	The Ship class must have a public void kill() method.
7.	The Ship class&#39;s kill() method must set the isAlive field to false.
8.	The Bullet class must have a public void kill() method.
9.	The Bullet class&#39;s kill() method must set the isAlive field to false.


Space Invaders (Part 15/34)

We'll store all the enemy projectiles in an enemyBullets field in the SpaceInvadersGame class. We'll add code to draw and move them in appropriate methods.
To remove projectiles that are no longer relevant, we'll create and implement a removeDeadBullets() method in the SpaceInvadersGame class.
To remove the projectiles, you can either use an iterator, or create a copy of the enemyBullets list and run through it in a loop.
If we determine that a projectile needs to be removed, we'll call enemyBullets.remove(bullet).
Projectiles are irrelevant if they have flown off the screen or if they have hit their target (isAlive == false).
Let's add a check() helper function. At this stage, it will call the removeDeadBullets() method. Later, it will perform various checks at each step of the game.
We'll call the fire() method on the fleet with the same frequency, potentially causing an enemy ship to fire.
If a shot is fired, the method returns a projectile, which must be added to the list.



Space Invaders (Part 14/34)

Let's create and implement a fire() method for the EnemyFleet class. This method will call the fire on a randomly selected ship in the fleet.
Additionally, the probability that the fleet will fire will be determined by the value of the DIFFICULTY field.



Space Invaders (Part 13/34)

Let's introduce a DIFFICULTY variable responsible for the game's difficulty, specifically the probability that an enemy ship will fire in a step of the game.
All ships should be able to fire, so we'll add a fire method to the Ship class.
We won't create any instances of this class, so this method will be a "stub". We'll implement it in child classes.
To make a projectile fly out of the front cannon, you need to pass the right coordinates to the constructor.



Space Invaders (Part 12/34)

We'll create a Bullet class responsible for the projectiles. This class's constructor will take x and y coordinates and a direction.
The constructor will also call the setMatrix method with the projectile's matrix (ShapeMatrix.BULLET), which you can find in the ShapeMatrix class.
Because the projectiles only fly up or down, only the y coordinate changes. We'll add a dy variable, which will be responsible for the magnitude of change in the y coordinate.
During upward flight, dy is negative. When flying down, it is positive. As a result, all we need to do in the move method is increase the y coordinate by dy.
We'll declare an isAlive variable that will indicate whether the projectile is "alive".
When created, it is "alive", but it "dies" if it hits an opponent's ship.
We'll implement this behavior later.



Space Invaders (Part 11/34)

When the ships reach the edge of the screen, they begin to move in the opposite direction and drop lower.
To achieve this, we need to implement the EnemyFleet class's move method.



