taskKey="com.codegym.games.spaceinvaders.part20"\n\nSpace Invaders (Part 20/34)

We'll create the nextFrame method in the Ship class to switch to the next animation frame.
It sets the matrix field to the next animation frame, if possible.
We'll extend the functionality of the draw method by overriding it so that it calls the superclass's method
for drawing and the nextFrame method for changing animation frames.


Requirements:
1.	The Ship class must have a public void nextFrame() method.
2.	The nextFrame() method must increase the frameIndex field by one.
3.	The nextFrame() method must not do anything if frameIndex is greater than or equal to the number of frames in the frames list.
4.	The nextFrame() method must set the matrix field equal to the frame in the frames list whose index is equal to frameIndex.
5.	In the Ship class, the void draw(Game) method of the parent class must be overridden.
6.	The Ship class&#39;s draw(Game game) method must call the superclass&#39;s method with game as the argument.
7.	The Ship class&#39;s draw(Game game) method must call the nextFrame() method.
8.	The Ship class must import the com.codegym.engine.cell.Game class.


Space Invaders (Part 19/34)

We'll implement logic to "kill" the player by overriding the kill() method. In addition to setting the isAlive flag to false,
it will add an animation of the ship's destruction.



Space Invaders (Part 18/34)

At this stage, we'll prepare an animation for when a ship explodes. To do this, we need a List<int[][]> frames field,
which will store a list of matrices representing the animation frames.
We'll also need a frameIndex field that stores the index of the current animation frame.
We'll set the animation frames in the setAnimatedView method. It takes an array of frames (matrices) and puts them in the frames list.
Finally, we'll implement the setStaticView method, which sets the ship's initial matrix.



Space Invaders (Part 17/34)

We'll give the PlayerShip class a method that checks whether enemy projectiles have hit the player's ship (the isCollision() method in the GameObject class).
If there is a hit, it will "kill" the ship and the projectile. We'll also add the player's ship to the class.
We'll draw it and add the collision check in the appropriate method.



Space Invaders (Part 16/34)

Now we'll create the player's ship. We need the PlayerShip class for this. Its constructor will set the ship's coordinates so that
the ship is displayed centered at the bottom of the screen. The constructor sets the ship's appearance by setting the PLAYER matrix,
which we've provided for you in the ShapeMatrix class. A ship can have two states: "alive" or "dead". To represent these states,
we'll add an isAlive field to the Ship parent class. When a projectile hits a ship, they (the projectile and the ship) are destroyed,
so we'll add a kill method. When it is called, we'll "kill" the ship and the projectile.



Space Invaders (Part 15/34)

We'll store all the enemy projectiles in an enemyBullets field in the SpaceInvadersGame class. We'll add code to draw and move them in appropriate methods.
To remove projectiles that are no longer relevant, we'll create and implement a removeDeadBullets() method in the SpaceInvadersGame class.
To remove the projectiles, you can either use an iterator, or create a copy of the enemyBullets list and run through it in a loop.
If we determine that a projectile needs to be removed, we'll call enemyBullets.remove(bullet).
Projectiles are irrelevant if they have flown off the screen or if they have hit their target (isAlive == false).
Let's add a check() helper function. At this stage, it will call the removeDeadBullets() method. Later, it will perform various checks at each step of the game.
We'll call the fire() method on the fleet with the same frequency, potentially causing an enemy ship to fire.
If a shot is fired, the method returns a projectile, which must be added to the list.



